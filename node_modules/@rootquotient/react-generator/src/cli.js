import arg from "arg";
import inquirer from "inquirer";
import {
  generateTemplate
} from "./main";
import {
  getDefaultPath
} from "./scripts/path";
import {
  errorLog,
  log
} from "./utils/logger";
import {
  convertToPascalCase
} from "./utils/toPascalCase";
import {
  convertToTitleCase
} from "./utils/toTitleCase";

function parseArgumentsIntoOptions(rawArgs) {
  const args = arg({
    "--component": Boolean,
    "--service": Boolean,
    "--project": Boolean,
    "--model": Boolean,
    "--form": Boolean,
    "--validator": Boolean,
    // '--test': Boolean,
    "--name": String,
    "-c": "--component",
    "-s": "--service",
    "-p": "--project",
    "-m": "--model",
    "-f": "--form",
    "-v": "--validator",
    // '-t': '--test',
    "-n": "--name",
  }, {
    argv: rawArgs.slice(2),
  });
  return {
    service: args["--service"] || false,
    model: args["--model"] || false,
    project: args["--project"] || false,
    form: args["--form"] || false,
    validator: args["--validator"] || false,
    name: args["--name"],
    component: args["--component"] || false,
    // test: args['--test'] || false,
    template: args._[0],
  };
}


async function promptForMissingOptions(options) {
  const templateQuestions = [];
  const templates = [];

  for (const key in options) {
    if (Object.hasOwnProperty.call(options, key)) {
      options[key] && key !== "name" && templates.push(key);
    }
  }

  if (!templates.length) {
    templateQuestions.push({
      type: "list",
      name: "template",
      message: "Please choose which project template to use (either Project or Component, Service, Model, Form and Validator)\n",
      validate: (values) =>
        !!values.length && !(values.length > 1 && values.includes("Project")),
      choices: [
        "Project",
        "Component",
        "Service",
        "Model",
        "Form",
        "Validator",
      ],
    });
  }

  const templateAnswers = await inquirer.prompt(templateQuestions);

  const nameQuestions = [];

  if (
    !options.name &&
    !(
      (templateAnswers.template &&
        templateAnswers.template === "Model") || templates.includes("model")
    )
  ) {
    if (
      !(
        templateAnswers.template.includes("Form") ||
        templates.includes("form") ||
        templateAnswers.template.includes("Validator") ||
        templates.includes("validator")
      )
    ) {
      nameQuestions.push({
        type: "input",
        name: "name",
        validate: (ans) => {
          if (!ans || !ans.trim())
            throw "Name can't be empty"
          else if (ans.trim().match(/[!"`'#%&,:;<>=@{}~_.\-\$\(\)\*\+\/\\\?\[\]\^\|]+/))
            throw "Name can't have special characters"
          else if (ans.split("").some(letter => letter.charCodeAt() > 64 && letter.charCodeAt() < 91))
            throw "Name should be space seperated words without any uppercase letters"
          else
            return !!ans
        },
        message: "Please enter the name for the template",
      });
    }
  }

  const nameAnswers = await inquirer.prompt(nameQuestions);

  if (
    options.component ||
    (templateAnswers.template &&
      (templateAnswers.template.includes("component") ||
        templateAnswers.template.includes("Component")))
  ) {
    const response = await inquirer.prompt({
      type: "confirm",
      name: "shared",
      message: "Do you want the component to be a shared component ?",
    });
    let path = getDefaultPath("Component", {
      isShared: true
    });
    if (!response.shared) {
      const response = await inquirer.prompt({
        type: "input",
        name: "path",
        validate: (ans) => !!ans,
        default: getDefaultPath("Component"),
        message: "Please enter the path for the component",
      });
      path = response.path;
    }
    options.path = path;
  }

  const formQuestions = [];
  let formName = {};
  let formAnswers = [];

  const formPath = {};
  if (templateAnswers.template.includes("Form")) {
    formName = await inquirer.prompt([{
      type: "input",
      name: "name",
      validate: (ans) => !!ans,
      // default: "Form",
      message: "Please enter the name for the template",
    }, ]);
    formQuestions.push({
      type: "list",
      name: "template",
      loop: true,
      message: "Add your components to the form\n",
      validate: (values) =>
        !!values.length && !(values.length > 1 && values.includes("Project")),
      choices: ["Input", "Select", "Date", "Radio", "Switch", "OTP"],
    });

    await promptFormOptionsRecursively(formQuestions).then((response) => {
      formAnswers = response.map((value) => value);
    });

    const path = await inquirer.prompt([{
      type: "input",
      name: "path",
      default: getDefaultPath("Form"),
      validate: (ans) => !!ans,
      message: "Please enter the path you want to add the form",
    }, ]);
    Object.assign(formPath, path);
  }

  const validatorQuestions = [{
    type: "checkbox",
    name: "validatorQuestions",
    message: "Please choose the criteria\n",
    validate: (values) => !!values.length,
    choices: [
      "string",
      "number",
      "email",
      "required",
      "mixed",
      "bool",
      "min",
      "max",
      "password (regex)",
      "custom (regex)",
    ],
  }, ];

  const validatorPath = {};
  let validatorName = {};

  let validatorAnswers = [];

  if (templateAnswers.template.includes("Validator")) {
    validatorName = await inquirer.prompt([{
      type: "input",
      name: "name",
      validate: (ans) => !!ans,
      // default: "Validator",
      message: "Please enter the name for the template",
    }, ]);
    await promptValidatorOptionsRecursively(validatorQuestions).then(
      (response) => {
        validatorAnswers = response.map((value) => value);
      }
    );

    const path = await inquirer.prompt([{
      type: "input",
      name: "path",
      default: getDefaultPath("Validator"),
      validate: (ans) => !!ans,
      message: "Please enter the path you want to add the validator",
    }, ]);

    Object.assign(validatorPath, path);
  }


  return {
    template: templates.length ?
      templates :
      templateAnswers.template.toLowerCase(),
    name: options.name || nameAnswers.name,
    extras: {
      formAnswers,
      validatorAnswers,
      formName: formName.name,
      validatorName: validatorName.name,
      formPath: formPath.path,
      validatorPath: validatorPath.path,
      path: options.path,
    },
  };
}

async function promptFormOptionsRecursively(formQuestions) {
  const formAnswers = [];
  return recursivePrompt();
  async function recursivePrompt() {
    const prompt = await inquirer.prompt(formQuestions);
    const namePrompt = await inquirer.prompt([{
      type: "input",
      name: "name",
      validate: (ans) => !!ans,
      message: "Please enter the name for the component",
    }, ]);

    formAnswers.push({
      ...prompt,
      ...namePrompt,
    });
    const confirmPrompt = await inquirer.prompt([{
      type: "confirm",
      name: "template",
      message: "Do you want to add another?\n",
    }, ]);
    if (confirmPrompt.template) {
      return recursivePrompt();
    } else {
      return formAnswers;
    }
  }
}

async function promptValidatorOptionsRecursively(validatorQuestions) {
  const validatorAnswers = [];
  return recursivePrompt();
  async function recursivePrompt() {
    const namePrompt = await inquirer.prompt([{
      type: "input",
      name: "name",
      validate: (ans) => !!ans,
      message: "Please enter the validation key",
    }, ]);
    const prompt = await inquirer.prompt(validatorQuestions);
    let extras = {};
    if (prompt.validatorQuestions.includes("min")) {
      const min = await inquirer.prompt([{
        type: "input",
        name: "min",
        validate: (ans) => !!ans,
        message: "Please enter the min range",
      }, ]);
      extras = {
        ...extras,
        ...min,
      };
    }
    if (prompt.validatorQuestions.includes("max")) {
      const max = await inquirer.prompt([{
        type: "input",
        name: "max",
        validate: (ans) => !!ans,
        message: "Please enter the max range",
      }, ]);
      extras = {
        ...extras,
        ...max,
      };
    }
    if (prompt.validatorQuestions.includes("custom (regex)")) {
      const regex = await inquirer.prompt([{
        type: "input",
        name: "regex",
        validate: (ans) => !!ans,
        message: "Please enter the regex",
      }, ]);

      const customErrorMessage = await inquirer.prompt([{
        type: "input",
        name: "customErrorMessage",
        validate: (ans) => !!ans,
        message: "Please enter the error message for the custom regex",
      }, ]);
      extras = {
        ...extras,
        ...customErrorMessage,
        ...regex,
      };
    }
    validatorAnswers.push({
      ...prompt,
      ...namePrompt,
      ...extras,
    });
    const confirmPrompt = await inquirer.prompt([{
      type: "confirm",
      name: "template",
      message: "Do you want to add another?\n",
    }, ]);
    if (confirmPrompt.template) {
      return recursivePrompt();
    } else {
      return validatorAnswers;
    }
  }
}

export async function cli(args) {
  let options = parseArgumentsIntoOptions(args);
  options = await promptForMissingOptions(options);
  generateTemplate(options.template, options.name, options.extras);
}